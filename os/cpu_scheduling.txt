FCFS

import java.util.Scanner;

class Process {
    int pid, arrivalTime, burstTime, waitingTime, turnaroundTime, completionTime;

    public Process(int pid, int arrivalTime, int burstTime) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
    }
}

public class FCFS_Scheduling {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input: Number of processes
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Input: Arrival time and Burst time for each process
        for (int i = 0; i < n; i++) {
            System.out.print("Enter arrival time and burst time for Process " + (i + 1) + ": ");
            int arrival = sc.nextInt();
            int burst = sc.nextInt();
            processes[i] = new Process(i + 1, arrival, burst);
        }

        // Sorting processes by Arrival Time (FCFS)
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (processes[j].arrivalTime > processes[j + 1].arrivalTime) {
                    Process temp = processes[j];
                    processes[j] = processes[j + 1];
                    processes[j + 1] = temp;
                }
            }
        }

        // FCFS Scheduling Calculation
        int currentTime = 0;
        float totalWaitingTime = 0, totalTurnaroundTime = 0;

        for (int i = 0; i < n; i++) {
            if (currentTime < processes[i].arrivalTime) {
                currentTime = processes[i].arrivalTime; // CPU idle time
            }

            processes[i].completionTime = currentTime + processes[i].burstTime;
            processes[i].turnaroundTime = processes[i].completionTime - processes[i].arrivalTime;
            processes[i].waitingTime = processes[i].turnaroundTime - processes[i].burstTime;

            totalWaitingTime += processes[i].waitingTime;
            totalTurnaroundTime += processes[i].turnaroundTime;
            currentTime = processes[i].completionTime;
        }

        // Output: Process Details
        System.out.println("\nProcess Chart:");
        System.out.println("-------------------------------------------------");
        System.out.printf("%-10s %-15s %-15s %-15s %-15s\n", "PID", "Burst Time", "Waiting Time", "Turnaround Time", "Completion Time");
        System.out.println("-------------------------------------------------");

        for (Process p : processes) {
            System.out.printf("%-10d %-15d %-15d %-15d %-15d\n", p.pid, p.burstTime, p.waitingTime, p.turnaroundTime, p.completionTime);
        }

        // Output: Average Waiting Time and Turnaround Time
        System.out.println("\nAverage Waiting Time: " + (totalWaitingTime / n));
        System.out.println("Average Turnaround Time: " + (totalTurnaroundTime / n));

        sc.close();
    }
}

=========================
output:

Enter number of processes: 3
Enter arrival time and burst time for Process 1: 0 5
Enter arrival time and burst time for Process 2: 1 3
Enter arrival time and burst time for Process 3: 2 8

Process Chart:
-------------------------------------------------
PID        Burst Time      Waiting Time    Turnaround Time  Completion Time
-------------------------------------------------
1          5              0               5               5
2          3              4               7               8
3          8              6               14              16

Average Waiting Time: 3.3333333
Average Turnaround Time: 8.666667

========================

Algorithm

ALGORITHM (FIRST COME FIRST SERVE):

STEP 1: Start the program.
STEP 2: Declare the arrays waiting time(wt), burst time(bt), turn around time(tat), arrival time(at), completion time(ct) as integer data type.
STEP 3: Read the number of processes in which we want to implement the FCFS.Read the arrival time and burst time for each process.
STEP 4: Using for loop, completion time, turnaround time, waiting time are calculated
STEP 5: Completion time for all processes is equal to sum of the burst time. Turnaround time is equal to the difference between completion time and arrival time.
STEP 6: Waiting time is equal to the difference in turnaround time and burst time.
STEP 7: Then corresponding total turnaround time and total waiting time are calculated. Then calculated turnaround time is displayed.
STEP 8: Stop the program


================================
================================

SJF

import java.util.Arrays;
import java.util.Scanner;

class Process {
    int pid, arrivalTime, burstTime, waitingTime, turnaroundTime, completionTime;

    public Process(int pid, int arrivalTime, int burstTime) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
    }
}

public class SJF_Scheduling {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input: Number of processes
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Input: Arrival time and Burst time for each process
        for (int i = 0; i < n; i++) {
            System.out.print("Enter arrival time and burst time for Process " + (i + 1) + ": ");
            int arrival = sc.nextInt();
            int burst = sc.nextInt();
            processes[i] = new Process(i + 1, arrival, burst);
        }

        // Sort by Arrival Time first
        Arrays.sort(processes, (p1, p2) -> Integer.compare(p1.arrivalTime, p2.arrivalTime));

        int currentTime = 0;
        float totalWaitingTime = 0, totalTurnaroundTime = 0;
        boolean[] completed = new boolean[n];

        for (int i = 0; i < n; i++) {
            int idx = -1;
            int minBurstTime = Integer.MAX_VALUE;

            // Find the process with the shortest burst time that has arrived and is not completed
            for (int j = 0; j < n; j++) {
                if (!completed[j] && processes[j].arrivalTime <= currentTime && processes[j].burstTime < minBurstTime) {
                    minBurstTime = processes[j].burstTime;
                    idx = j;
                }
            }

            // If no process has arrived yet, move time forward
            if (idx == -1) {
                currentTime++;
                i--;
                continue;
            }

            // Process execution
            currentTime += processes[idx].burstTime;
            processes[idx].completionTime = currentTime;
            processes[idx].turnaroundTime = processes[idx].completionTime - processes[idx].arrivalTime;
            processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;

            totalWaitingTime += processes[idx].waitingTime;
            totalTurnaroundTime += processes[idx].turnaroundTime;
            completed[idx] = true;
        }

        // Output: Process Details
        System.out.println("\nProcess Chart:");
        System.out.println("-------------------------------------------------");
        System.out.printf("%-10s %-15s %-15s %-15s %-15s\n", "PID", "Burst Time", "Waiting Time", "Turnaround Time", "Completion Time");
        System.out.println("-------------------------------------------------");

        for (Process p : processes) {
            System.out.printf("%-10d %-15d %-15d %-15d %-15d\n", p.pid, p.burstTime, p.waitingTime, p.turnaroundTime, p.completionTime);
        }

        // Output: Average Waiting Time and Turnaround Time
        System.out.println("\nAverage Waiting Time: " + (totalWaitingTime / n));
        System.out.println("Average Turnaround Time: " + (totalTurnaroundTime / n));

        sc.close();
    }
}


===============================
output:

Enter number of processes: 3
Enter arrival time and burst time for Process 1: 0 6
Enter arrival time and burst time for Process 2: 2 8
Enter arrival time and burst time for Process 3: 4 7

Process Chart:
-------------------------------------------------
PID        Burst Time      Waiting Time    Turnaround Time  Completion Time
-------------------------------------------------
1          6              0               6               6
3          7              2               9               13
2          8              5               13              21

Average Waiting Time: 2.3333333
Average Turnaround Time: 9.333333

===========================
ALGORITHM (SHORTEST JOB FIRST):

STEP 1: Start the program.
STEP 2: Declare the arrays burst time, turn around time, waiting time and the number of process of integer data type and average waiting time and average turn around time as float data type.
STEP 3: Read the values of the burst time for the processes. Then sorting of burst time takes place. This program executes according to the sorted order of the burst time 
STEP 4: According to the burst time that are sorted the processes are rescheduled and also the waiting time and turn around time are calculated.
STEP 5: The corresponding average waiting time and average turnaround time are calculated. Then the result has been displayed.
STEP 6: Stop the program.


=============================
===================

priority

import java.util.Arrays;
import java.util.Scanner;

class Process {
    int pid, arrivalTime, burstTime, priority, waitingTime, turnaroundTime, completionTime;

    public Process(int pid, int arrivalTime, int burstTime, int priority) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.priority = priority;
    }
}

public class PriorityScheduling {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input: Number of processes
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Input: Arrival time, Burst time, and Priority for each process
        for (int i = 0; i < n; i++) {
            System.out.print("Enter arrival time, burst time, and priority for Process " + (i + 1) + ": ");
            int arrival = sc.nextInt();
            int burst = sc.nextInt();
            int priority = sc.nextInt();
            processes[i] = new Process(i + 1, arrival, burst, priority);
        }

        // Sort by Priority (Lower priority value = Higher priority)
        Arrays.sort(processes, (p1, p2) -> {
            if (p1.priority == p2.priority) {
                return Integer.compare(p1.arrivalTime, p2.arrivalTime); // Sort by arrival time if priority is same
            }
            return Integer.compare(p1.priority, p2.priority);
        });

        int currentTime = 0;
        float totalWaitingTime = 0, totalTurnaroundTime = 0;
        boolean[] completed = new boolean[n];

        for (int i = 0; i < n; i++) {
            int idx = -1;
            int highestPriority = Integer.MAX_VALUE;

            // Find the highest priority process that has arrived and is not completed
            for (int j = 0; j < n; j++) {
                if (!completed[j] && processes[j].arrivalTime <= currentTime && processes[j].priority < highestPriority) {
                    highestPriority = processes[j].priority;
                    idx = j;
                }
            }

            // If no process is available, move time forward
            if (idx == -1) {
                currentTime++;
                i--;
                continue;
            }

            // Execute the selected process
            currentTime += processes[idx].burstTime;
            processes[idx].completionTime = currentTime;
            processes[idx].turnaroundTime = processes[idx].completionTime - processes[idx].arrivalTime;
            processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;

            totalWaitingTime += processes[idx].waitingTime;
            totalTurnaroundTime += processes[idx].turnaroundTime;
            completed[idx] = true;
        }

        // Output: Process Details
        System.out.println("\nProcess Chart:");
        System.out.println("---------------------------------------------------------");
        System.out.printf("%-10s %-15s %-10s %-15s %-15s %-15s\n", "PID", "Burst Time", "Priority", "Waiting Time", "Turnaround Time", "Completion Time");
        System.out.println("---------------------------------------------------------");

        for (Process p : processes) {
            System.out.printf("%-10d %-15d %-10d %-15d %-15d %-15d\n", p.pid, p.burstTime, p.priority, p.waitingTime, p.turnaroundTime, p.completionTime);
        }

        // Output: Average Waiting Time and Turnaround Time
        System.out.println("\nAverage Waiting Time: " + (totalWaitingTime / n));
        System.out.println("Average Turnaround Time: " + (totalTurnaroundTime / n));

        sc.close();
    }
}


================================
output:

Enter number of processes: 3
Enter arrival time, burst time, and priority for Process 1: 0 4 3
Enter arrival time, burst time, and priority for Process 2: 1 3 1
Enter arrival time, burst time, and priority for Process 3: 2 5 2

Process Chart:
---------------------------------------------------------
PID        Burst Time     Priority   Waiting Time   Turnaround Time  Completion Time
---------------------------------------------------------
2          3             1          0              3                4
3          5             2          2              7                9
1          4             3          5              9                13

Average Waiting Time: 2.3333333
Average Turnaround Time: 6.333333


=========================

ALGORITHM (PRIORITY SCHEDULING):

STEP 1: Start the program.
STEP 2:Declare the array for burst time,priority,turn around time and some iteratable variables for using it in a looping structure.
STEP 3: Read the burst time for all processes. The processes are sorted based on the priority.
STEP 4: As the name suggests, the processes are sorted based on the priority. The waiting time has been initialised to zero. The waiting time and turn around time has been calculated.
STEP 5: The average waiting time and average turn around time has been calculated.
STEP 6: Stop the program.  


===============================
=============================
RR

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

class Process {
    int pid, arrivalTime, burstTime, remainingTime, waitingTime, turnaroundTime, completionTime;

    public Process(int pid, int arrivalTime, int burstTime) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.remainingTime = burstTime;
    }
}

public class RoundRobinScheduling {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input: Number of processes
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Input: Arrival time and Burst time for each process
        for (int i = 0; i < n; i++) {
            System.out.print("Enter arrival time and burst time for Process " + (i + 1) + ": ");
            int arrival = sc.nextInt();
            int burst = sc.nextInt();
            processes[i] = new Process(i + 1, arrival, burst);
        }

        // Input: Time Quantum
        System.out.print("Enter time quantum: ");
        int quantum = sc.nextInt();

        // Initialize variables
        Queue<Process> queue = new LinkedList<>();
        int currentTime = 0, completed = 0;
        float totalWaitingTime = 0, totalTurnaroundTime = 0;

        // Add processes to queue when they arrive
        boolean[] inQueue = new boolean[n];
        for (Process p : processes) {
            if (p.arrivalTime == 0) {
                queue.add(p);
                inQueue[p.pid - 1] = true;
            }
        }

        // Round Robin Execution
        while (completed < n) {
            if (queue.isEmpty()) {
                currentTime++; // If no process is available, move time forward
                for (Process p : processes) {
                    if (!inQueue[p.pid - 1] && p.arrivalTime <= currentTime) {
                        queue.add(p);
                        inQueue[p.pid - 1] = true;
                    }
                }
                continue;
            }

            Process currentProcess = queue.poll();

            // Execute process for time quantum or remaining time
            int executionTime = Math.min(quantum, currentProcess.remainingTime);
            currentProcess.remainingTime -= executionTime;
            currentTime += executionTime;

            // Add newly arrived processes to queue
            for (Process p : processes) {
                if (!inQueue[p.pid - 1] && p.arrivalTime <= currentTime) {
                    queue.add(p);
                    inQueue[p.pid - 1] = true;
                }
            }

            // If process is completed
            if (currentProcess.remainingTime == 0) {
                completed++;
                currentProcess.completionTime = currentTime;
                currentProcess.turnaroundTime = currentProcess.completionTime - currentProcess.arrivalTime;
                currentProcess.waitingTime = currentProcess.turnaroundTime - currentProcess.burstTime;

                totalWaitingTime += currentProcess.waitingTime;
                totalTurnaroundTime += currentProcess.turnaroundTime;
            } else {
                queue.add(currentProcess); // Re-add process to queue if not finished
            }
        }

        // Output: Process Details
        System.out.println("\nProcess Chart:");
        System.out.println("-------------------------------------------------");
        System.out.printf("%-10s %-15s %-15s %-15s %-15s\n", "PID", "Burst Time", "Waiting Time", "Turnaround Time", "Completion Time");
        System.out.println("-------------------------------------------------");

        for (Process p : processes) {
            System.out.printf("%-10d %-15d %-15d %-15d %-15d\n", p.pid, p.burstTime, p.waitingTime, p.turnaroundTime, p.completionTime);
        }

        // Output: Average Waiting Time and Turnaround Time
        System.out.println("\nAverage Waiting Time: " + (totalWaitingTime / n));
        System.out.println("Average Turnaround Time: " + (totalTurnaroundTime / n));

        sc.close();
    }
}

========================
output:

Enter number of processes: 3
Enter arrival time and burst time for Process 1: 0 7
Enter arrival time and burst time for Process 2: 1 4
Enter arrival time and burst time for Process 3: 2 6
Enter time quantum: 3

Process Chart:
-------------------------------------------------
PID        Burst Time      Waiting Time    Turnaround Time  Completion Time
-------------------------------------------------
1          7              5               12              12
2          4              5               9               10
3          6              6               12              14

Average Waiting Time: 5.3333335
Average Turnaround Time: 11.0

===============================
ALGORITHM (ROUND ROBIN SCHEDULING):

STEP 1: Start the program.
STEP 2: Declare the arrays arrival time, burst time, turn around time as integer data type and average waiting time and average turn around time as float data type. Read the total number of processes.
STEP 3: Read the time quantum for the processes and burst time for each process.
STEP 4: Each process should run till the time quantum. After that it skips that processes and move on to the next process. Waiting time and turn around time are calculated.
STEP 5: Average waiting time and average turnaround time are calculated.
STEP 6: Stop the program.

=================================
===============================

SRTF

import java.util.*;

class Process {
    int pid, arrivalTime, burstTime, remainingTime, waitingTime, turnaroundTime, completionTime;

    public Process(int pid, int arrivalTime, int burstTime) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.remainingTime = burstTime;
    }
}

public class SRTFScheduling {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input: Number of processes
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Input: Arrival time and Burst time for each process
        for (int i = 0; i < n; i++) {
            System.out.print("Enter arrival time and burst time for Process " + (i + 1) + ": ");
            int arrival = sc.nextInt();
            int burst = sc.nextInt();
            processes[i] = new Process(i + 1, arrival, burst);
        }

        // Sort processes by arrival time
        Arrays.sort(processes, Comparator.comparingInt(p -> p.arrivalTime));

        int currentTime = 0, completed = 0;
        float totalWaitingTime = 0, totalTurnaroundTime = 0;
        Process currentProcess = null;

        while (completed < n) {
            Process shortest = null;
            int minRemainingTime = Integer.MAX_VALUE;

            // Find the process with the shortest remaining time at the current time
            for (Process p : processes) {
                if (p.arrivalTime <= currentTime && p.remainingTime > 0 && p.remainingTime < minRemainingTime) {
                    minRemainingTime = p.remainingTime;
                    shortest = p;
                }
            }

            if (shortest == null) {
                currentTime++; // If no process is available, move time forward
                continue;
            }

            // Execute the process for 1 time unit
            shortest.remainingTime--;
            currentTime++;

            // If the process is completed
            if (shortest.remainingTime == 0) {
                completed++;
                shortest.completionTime = currentTime;
                shortest.turnaroundTime = shortest.completionTime - shortest.arrivalTime;
                shortest.waitingTime = shortest.turnaroundTime - shortest.burstTime;

                totalWaitingTime += shortest.waitingTime;
                totalTurnaroundTime += shortest.turnaroundTime;
            }
        }

        // Output: Process Details
        System.out.println("\nProcess Chart:");
        System.out.println("------------------------------------------------------");
        System.out.printf("%-10s %-15s %-15s %-15s %-15s\n", "PID", "Arrival Time", "Burst Time", "Waiting Time", "Turnaround Time");
        System.out.println("------------------------------------------------------");

        for (Process p : processes) {
            System.out.printf("%-10d %-15d %-15d %-15d %-15d\n", p.pid, p.arrivalTime, p.burstTime, p.waitingTime, p.turnaroundTime);
        }

        // Output: Average Waiting Time and Turnaround Time
        System.out.println("\nAverage Waiting Time: " + (totalWaitingTime / n));
        System.out.println("Average Turnaround Time: " + (totalTurnaroundTime / n));

        sc.close();
    }
}


=======================
output:

Enter number of processes: 3
Enter arrival time and burst time for Process 1: 0 6
Enter arrival time and burst time for Process 2: 2 8
Enter arrival time and burst time for Process 3: 4 7

Process Chart:
------------------------------------------------------
PID        Arrival Time    Burst Time      Waiting Time   Turnaround Time
------------------------------------------------------
1          0              6              0              6
2          2              8              9              17
3          4              7              5              12

Average Waiting Time: 4.666667
Average Turnaround Time: 11.666667

===========================

ALGORITHM (SHORTEST REMAINING TIME FIRST):

STEP 1: Start the program.
STEP 2: Declare the arrays burst time, arrivaltime, waitingtime, turn around time and iteratablevariables are of integer data type 
STEP 3: Read the number of processes, bursttime, arrival time as the input.
STEP 4:Using arrival time calculate which process has to execute first by comparing the burst time. 
STEP 5:Calculate the waiting time, turn around time, and their average waiting time and average turnaround time. 
STEP 6: Stop the program. 


